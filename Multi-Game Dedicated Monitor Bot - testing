# -*- coding: utf-8 -*-
import os
import asyncio
import json
import re
from datetime import datetime
from discord.ext import commands, tasks
from discord import Intents, Status, Game, Embed, Colour
from rcon.asyncio import RconAsync, RCONException

# ==============================================================================
# ‚ö†Ô∏è CONFIGURATION BLOCK ‚ö†Ô∏è
# Update these settings before running the bot.
# ==============================================================================

# --- DISCORD CONFIGURATION ---
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN', "YOUR_DISCORD_BOT_TOKEN_HERE")
# Channel where player joins/leaves and auto-saves are announced
TARGET_CHANNEL_ID = int(os.getenv('TARGET_CHANNEL_ID', 0)) 
# Channel for administrative logs and errors (can be the same as TARGET_CHANNEL_ID)
LOG_CHANNEL_ID = int(os.getenv('LOG_CHANNEL_ID', TARGET_CHANNEL_ID)) 

# --- RCON CONFIGURATION ---
# Minecraft
MC_RCON_HOST = os.getenv('MC_RCON_HOST', "127.0.0.1")
MC_RCON_PORT = int(os.getenv('MC_RCON_PORT', 25575))
MC_RCON_PASSWORD = os.getenv('MC_RCON_PASSWORD', "YOUR_MC_RCON_PASSWORD_HERE")

# Palworld
PAL_RCON_HOST = os.getenv('PAL_RCON_HOST', "127.0.0.1")
PAL_RCON_PORT = int(os.getenv('PAL_RCON_PORT', 25576))
PAL_RCON_PASSWORD = os.getenv('PAL_RCON_PASSWORD', "YOUR_PAL_RCON_PASSWORD_HERE")
PAL_BAN_LIST_FILE = "palworld_ban_list.json" # File to store locally banned player IDs

# ASA (ARK: Survival Ascended)
ASA_RCON_HOST = os.getenv('ASA_RCON_HOST', "127.0.0.1")
ASA_RCON_PORT = int(os.getenv('ASA_RCON_PORT', 27020))
ASA_RCON_PASSWORD = os.getenv('ASA_RCON_PASSWORD', "YOUR_ASA_RCON_PASSWORD_HERE")
ASA_SERVER_NAME = os.getenv('ASA_SERVER_NAME', "ASA Dedicated Server")

# --- MONITORING/TASK CONFIGURATION ---
AUTO_SAVE_INTERVAL_MINUTES = int(os.getenv('AUTO_SAVE_INTERVAL_MINUTES', 30))
SERVER_POLL_INTERVAL_SECONDS = int(os.getenv('SERVER_POLL_INTERVAL_SECONDS', 15))


# ==============================================================================
# BOT SETUP & UTILITIES
# ==============================================================================

# Initialize the Bot
intents = Intents.default()
intents.message_content = True
intents.guilds = True
bot = commands.Bot(command_prefix='!', intents=intents)

# Dictionary to hold the last known player list for each game
last_player_list = {
    'mc': [],
    'pal': [],
    'asa': []
}

# Global set to hold locally banned Palworld IDs (UIDs or SteamIDs)
PAL_BAN_LIST_IDS = set() 

def _load_pal_ban_list():
    """Loads the Palworld ban list from the JSON file."""
    global PAL_BAN_LIST_IDS
    if os.path.exists(PAL_BAN_LIST_FILE):
        try:
            with open(PAL_BAN_LIST_FILE, 'r') as f:
                data = json.load(f)
                if isinstance(data, list):
                    PAL_BAN_LIST_IDS = set(data)
                else:
                    PAL_BAN_LIST_IDS = set()
        except Exception as e:
            print(f"Error loading Palworld ban list: {e}. Starting with empty list.")
            PAL_BAN_LIST_IDS = set()
    else:
        # Create an empty file if it doesn't exist
        _save_pal_ban_list()


def _save_pal_ban_list():
    """Saves the current Palworld ban list to the JSON file."""
    try:
        with open(PAL_BAN_LIST_FILE, 'w') as f:
            # Convert set to list for JSON serialization
            json.dump(list(PAL_BAN_LIST_IDS), f, indent=4)
    except Exception as e:
        print(f"Error saving Palworld ban list: {e}")

# Centralized RCON Configuration Map
GAME_RCON_CONFIGS = {
    'mc': {'host': MC_RCON_HOST, 'port': MC_RCON_PORT, 'pass': MC_RCON_PASSWORD, 'name': 'Minecraft', 'list_cmd': 'list', 'status_cmd': 'list'},
    'pal': {'host': PAL_RCON_HOST, 'port': PAL_RCON_PORT, 'pass': PAL_RCON_PASSWORD, 'name': 'Palworld', 'list_cmd': 'ShowPlayers', 'status_cmd': 'info'},
    'asa': {'host': ASA_RCON_HOST, 'port': ASA_RCON_PORT, 'pass': ASA_RCON_PASSWORD, 'name': ASA_SERVER_NAME, 'list_cmd': 'ListPlayers', 'status_cmd': 'GetServerTime'}, 
}

async def run_rcon_command(host: str, port: int, password: str, command: str) -> str:
    """Generic RCON execution function with timeout and error handling."""
    if not host or not password or port <= 0:
        return "Command Failed: RCON configuration is incomplete or invalid."

    rcon = RconAsync(host, port, password)
    try:
        await rcon.connect()
        response = await asyncio.wait_for(rcon.execute(command), timeout=5)
        # ARK/ASA often wraps messages in HTML tags, remove them
        if 'asa' in command.lower() or 'ark' in command.lower():
             response = re.sub(r'<[^>]+>', '', response)
        return response.strip()
    except RCONException as e:
        print(f"RCON Authentication/Connection Error to {host}:{port}: {e}")
        return f"Command Failed: RCON connection error or bad password/host."
    except asyncio.TimeoutError:
        print(f"RCON Timeout Error to {host}:{port} for command: {command}")
        return "Command Failed: RCON command timed out."
    except Exception as e:
        print(f"Unexpected RCON Error to {host}:{port}: {e}")
        return f"Command Failed: An unexpected error occurred: {e}"
    finally:
        try:
            if 'rcon' in locals(): await rcon.close()
        except:
            pass

# ==============================================================================
# UNIVERSAL COMMANDS
# ==============================================================================

@bot.command(name='status', help='Checks the RCON status of a server. Usage: !status <mc/pal/asa>')
async def status_check(ctx, game: str):
    """Checks the RCON connection and basic server status for a game."""
    game_id = game.lower()
    config = GAME_RCON_CONFIGS.get(game_id)
    
    if not config:
        return await ctx.send(f"‚ùå Unknown game ID. Use one of the following: `{'`, `'.join(GAME_RCON_CONFIGS.keys())}`.")
    
    await ctx.send(f"üì° Checking **{config['name']}** RCON status...")
    
    # Use a simple, non-destructive command for status check
    response = await run_rcon_command(config['host'], config['port'], config['pass'], config['status_cmd'])

    if "Command Failed" in response:
        await ctx.send(f"‚ùå **{config['name']}** server RCON FAILED. Server is likely **OFFLINE** or RCON credentials are wrong.")
    else:
        await ctx.send(f"‚úÖ **{config['name']}** server is **ONLINE** and RCON is responsive! Response to `{config['status_cmd']}`: `{response[:100]}...`")


@bot.command(name='players', help='Lists all connected players. Usage: !players <mc/pal/asa>')
async def list_players_generic(ctx, game: str):
    """Lists all connected players for the specified server."""
    game_id = game.lower()
    config = GAME_RCON_CONFIGS.get(game_id)
    
    if not config:
        return await ctx.send(f"‚ùå Unknown game ID. Use one of the following: `{'`, `'.join(GAME_RCON_CONFIGS.keys())}`.")

    await ctx.send(f"üë• Listing players on **{config['name']}**...")
    response = await run_rcon_command(config['host'], config['port'], config['pass'], config['list_cmd'])
    
    if "Command Failed" in response:
        return await ctx.send(f"‚ùå Failed to get player list for **{config['name']}**. Error: `{response}`")
        
    # Attempt to parse and format the player list
    player_count = 0
    player_names = []
    
    if game_id == 'mc':
        match = re.search(r"There are (\d+) of \d+ players online:(.*)", response)
        if match:
            player_count = int(match.group(1))
            player_names = [p.strip() for p in match.group(2).split(',') if p.strip()]
            
    elif game_id in ['pal', 'asa']:
        lines = response.split('\n')
        # Filter out header/empty lines and extract the name (first column)
        player_names = [line.split(',')[0].strip() for line in lines if line.count(',') >= 2 and line.split(',')[0].strip() not in ('Name', 'PlayerName', '')]
        player_count = len(player_names)

    embed = Embed(
        title=f"üë• {config['name']} Players ({player_count} Online)", 
        color=Colour.blue() if player_count > 0 else Colour.light_grey()
    )
    embed.description = '\n'.join([f"‚Ä¢ `{name}`" for name in player_names]) if player_names else "No players currently connected."
    
    await ctx.send(embed=embed)


@bot.command(name='rcon_raw', help='[Admin] Sends a custom, raw RCON command. Usage: !rcon_raw <mc/pal/asa> <command>')
@commands.has_permissions(administrator=True)
async def rcon_raw_command(ctx, game: str, *, command: str):
    """Sends a raw RCON command to the specified server."""
    game_id = game.lower()
    config = GAME_RCON_CONFIGS.get(game_id)
    
    if not config:
        return await ctx.send(f"‚ùå Unknown game ID. Use one of the following: `{'`, `'.join(GAME_RCON_CONFIGS.keys())}`.")
    
    await ctx.send(f"üíª Executing raw command on **{config['name']}**: `{command}`")
    response = await run_rcon_command(config['host'], config['port'], config['pass'], command)
    
    if "Command Failed" in response:
        await ctx.send(f"‚ùå Raw command failed. Error: `{response}`")
    else:
        # Display the full raw response
        await ctx.send(f"**{config['name']} Raw Response:**\n
1500]\n```")
# ==============================================================================
# MC COMMANDS (Minecraft)
# ==============================================================================

@bot.group(invoke_without_command=True, aliases=['mc'], help="Commands for Minecraft Server.")
async def minecraft(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send("Please specify a Minecraft command: `!mc say`, `!mc kick`, `!mc ban`, `!mc whitelist`.")

# Function to execute Minecraft RCON command
async def run_mc_rcon_command(command: str):
    return await run_rcon_command(MC_RCON_HOST, MC_RCON_PORT, MC_RCON_PASSWORD, command)

@minecraft.command(name="say", help="[Admin] Sends a message to all Minecraft players.")
@commands.has_permissions(administrator=True)
async def mc_say(ctx, *, message: str):
    await ctx.defer()
    command = f"say {message}"
    response = await run_mc_rcon_command(command)
    await ctx.send(f"üì£ Message sent to Minecraft. RCON Response: `{response.strip()}`")

@minecraft.command(name="kick", help="[Admin] Kicks a player from the Minecraft server.")
@commands.has_permissions(administrator=True)
async def mc_kick(ctx, player: str, *, reason: str = "Kicked by admin"):
    await ctx.defer()
    command = f"kick {player} {reason}"
    response = await run_mc_rcon_command(command)
    await ctx.send(f"üë¢ Player **{player}** kicked. RCON Response: `{response.strip()}`")

@minecraft.command(name="ban", help="[Admin] Bans a player from the Minecraft server.")
@commands.has_permissions(administrator=True)
async def mc_ban(ctx, player: str, *, reason: str = "Banned by admin"):
    await ctx.defer()
    command = f"ban {player} {reason}"
    response = await run_mc_rcon_command(command)
    await ctx.send(f"üî® Player **{player}** banned. RCON Response: `{response.strip()}`")

@minecraft.command(name="whitelist", help="[Admin] Adds or removes a player from the whitelist. Use `add` or `remove`.")
@commands.has_permissions(administrator=True)
async def mc_whitelist(ctx, action: str, player: str):
    await ctx.defer()
    action = action.lower()
    if action not in ['add', 'remove']:
        await ctx.send("‚ùå Invalid action. Use `add` or `remove`.")
        return

    command = f"whitelist {action} {player}"
    response = await run_mc_rcon_command(command)
    await ctx.send(f"üìù Whitelist {action} executed for **{player}**. RCON Response: `{response.strip()}`")


# ==============================================================================
# PAL COMMANDS (Palworld)
# ==============================================================================

@bot.group(invoke_without_command=True, aliases=['pal'], help="Commands for Palworld Server.")
async def palworld(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send("Please specify a Palworld command: `!pal say`, `!pal kick`, `!pal ban`, `!pal unban`, `!pal bans`, `!pal save`, `!pal shutdown`.")

# Function to execute Palworld RCON command
async def run_pal_rcon_command(command: str):
    return await run_rcon_command(PAL_RCON_HOST, PAL_RCON_PORT, PAL_RCON_PASSWORD, command)


@palworld.command(name="say", help="[Admin] Sends a message to all Palworld players.")
@commands.has_permissions(administrator=True)
async def pal_say(ctx, *, message: str):
    await ctx.defer()
    command = f"Broadcast {message}"
    response = await run_pal_rcon_command(command)
    await ctx.send(f"üì£ Message sent to Palworld. RCON Response: `{response.strip()}`")

@palworld.command(name="kick", help="[Admin] Kicks a player from the Palworld server by Steam ID or UID.")
@commands.has_permissions(administrator=True)
async def pal_kick(ctx, identifier: str):
    await ctx.defer()
    command = f"KickPlayer {identifier}"
    response = await run_pal_rcon_command(command)
    await ctx.send(f"üë¢ Player **{identifier}** kicked from Palworld. RCON Response: `{response.strip()}`")


@palworld.command(name="ban", help="[Admin] Kicks a player and adds their Steam ID/UID to the bot's local ban list.")
@commands.has_permissions(administrator=True)
async def pal_ban(ctx, identifier: str):
    """Kicks a player and locally blacklists their ID (UID or SteamID) for automatic future kicks."""
    global PAL_BAN_LIST_IDS
    await ctx.defer()
    
    # 1. Add to local ban list
    PAL_BAN_LIST_IDS.add(identifier.strip())
    _save_pal_ban_list()
    
    # 2. Kick the player immediately
    command = f"KickPlayer {identifier}"
    response = await run_pal_rcon_command(command)
    
    await ctx.send(f"üî® Palworld: **{identifier}** has been added to the local ban list and kicked. They will be automatically kicked if they try to join. RCON Response: `{response.strip()}`")


@palworld.command(name="unban", help="[Admin] Removes an ID from the bot's local ban list.")
@commands.has_permissions(administrator=True)
async def pal_unban(ctx, identifier: str):
    """Removes an ID (UID or SteamID) from the bot's local ban list."""
    global PAL_BAN_LIST_IDS
    await ctx.defer()
    
    identifier = identifier.strip()
    
    if identifier in PAL_BAN_LIST_IDS:
        PAL_BAN_LIST_IDS.remove(identifier)
        _save_pal_ban_list()
        await ctx.send(f"‚úÖ Palworld: **{identifier}** has been removed from the local ban list.")
    else:
        await ctx.send(f"‚ùå Palworld: **{identifier}** was not found in the local ban list.")


@palworld.command(name="bans", help="[Admin] Displays the bot's current local ban list.")
@commands.has_permissions(administrator=True)
async def pal_bans(ctx):
    """Displays the list of currently blacklisted IDs."""
    global PAL_BAN_LIST_IDS
    await ctx.defer()
    
    if PAL_BAN_LIST_IDS:
        bans_list = '\n'.join([f"‚Ä¢ `{id_}`" for id_ in sorted(list(PAL_BAN_LIST_IDS))])
        embed = Embed(
            title="üî® Palworld Local Ban List",
            description=f"These IDs will be automatically kicked on join:\n{bans_list}",
            color=Colour.red()
        )
        await ctx.send(embed=embed)
    else:
        await ctx.send("‚úÖ The Palworld local ban list is currently empty.")


@palworld.command(name="shutdown", help="[Admin] Shuts down the Palworld server after a delay (e.g., `!pal shutdown 60 Server restarting in 1 min`).")
@commands.has_permissions(administrator=True)
async def pal_shutdown(ctx, delay_seconds: int, *, message: str):
    await ctx.defer()
    command = f"Shutdown {delay_seconds} {message}"
    response = await run_pal_rcon_command(command)
    await ctx.send(f"üõë Palworld shutdown initiated in **{delay_seconds} seconds** with message: '{message}'. RCON Response: `{response.strip()}`")

@palworld.command(name="save", help="[Admin] Forces the Palworld server to save the world.")
@commands.has_permissions(administrator=True)
async def pal_save(ctx):
    await ctx.defer()
    command = "Save"
    response = await run_pal_rcon_command(command)
    
    if "Save Complete" in response:
        await ctx.send("üíæ Palworld World save completed successfully!")
    else:
        await ctx.send(f"‚ùå Failed to force save the Palworld world. RCON Response: `{response.strip()}`")


# ==============================================================================
# ASA COMMANDS (ARK: Survival Ascended)
# ==============================================================================

@bot.group(invoke_without_command=True, aliases=['ark', 'asa'], help="Commands for ARK: Survival Ascended (ASA) Server.")
async def asa(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send("Please specify an ASA command: `!asa say`, `!asa kick`, `!asa ban`, `!asa unban`, `!asa save`, `!asa shutdown`, `!asa settime`, `!asa creative`, `!asa doexit`.")

# Function to execute ASA RCON command
async def run_asa_rcon_command(command: str):
    return await run_rcon_command(ASA_RCON_HOST, ASA_RCON_PORT, ASA_RCON_PASSWORD, command)

async def _execute_asa_graceful_shutdown(ctx, total_minutes: int, message: str):
    """Helper for graceful, timed ASA shutdown with RCON messaging."""
    game_id = 'asa'
    config = GAME_RCON_CONFIGS.get(game_id)
    
    if not config:
        await ctx.send("Internal configuration error for ASA.")
        return

    await ctx.send(f"‚ö†Ô∏è **{config['name']}** - Initiating **{total_minutes}** minute graceful shutdown sequence...")
    
    # Define warning points (10, 5, 2, 1, 0.5)
    standard_warnings = [10, 5, 2, 1, 0.5] 
    
    # Only include warnings that are less than the total shutdown time
    warnings_to_issue = sorted([w for w in standard_warnings if w < total_minutes], reverse=True)
    
    current_minutes_remaining = total_minutes

    # Send the initial message immediately
    await run_rcon_command(config['host'], config['port'], config['pass'], f"Broadcast {message}")

    for warn_m in warnings_to_issue:
        sleep_minutes = current_minutes_remaining - warn_m
        if sleep_minutes > 0:
            await asyncio.sleep(sleep_minutes * 60)
            
        warning_msg = f"SERVER RESTART: Server is restarting in {warn_m} minute(s)!"
        await run_rcon_command(config['host'], config['port'], config['pass'], f"Broadcast {warning_msg}")
        current_minutes_remaining = warn_m
            
    # Final 30 seconds warning
    if current_minutes_remaining >= 1:
        await asyncio.sleep(30)
        await run_rcon_command(config['host'], config['port'], config['pass'], "Broadcast Server shutting down in 30 seconds!")
        current_minutes_remaining = 0.5
        
    # Final sleep to reach 0
    if current_minutes_remaining > 0:
        await asyncio.sleep(current_minutes_remaining * 60)
        
    # Final Save and Shutdown
    await ctx.send(f"üö® **{config['name']}** - Shutting down NOW!")
    await run_rcon_command(config['host'], config['port'], config['pass'], "SaveWorld")
    
    # Execute shutdown (DoExit)
    response = await run_rcon_command(config['host'], config['port'], config['pass'], "DoExit")
    
    if "Command Failed" in response:
        await ctx.send(f"‚ùå Shutdown command sent but RCON returned an error: `{response}`")
    else:
        await ctx.send(f"‚úÖ **{config['name']}** server sent shutdown command (`DoExit`).")


@asa.command(name="say", help="[Admin] Sends a message to all ASA players.")
@commands.has_permissions(administrator=True)
async def asa_say(ctx, *, message: str):
    await ctx.defer()
    command = f"Broadcast {message}"
    response = await run_asa_rcon_command(command)
    await ctx.send(f"üì£ Message sent to ASA. RCON Response: `{response.strip()}`")

@asa.command(name="kick", help="[Admin] Kicks a player from the ASA server by Steam ID or name.")
@commands.has_permissions(administrator=True)
async def asa_kick(ctx, identifier: str):
    await ctx.defer()
    command = f"KickPlayer {identifier}"
    response = await run_asa_rcon_command(command)
    
    if "Command Failed" in response or "Unknown Command" in response:
        await ctx.send(f"‚ùå Could not kick player **{identifier}** from ASA. RCON Response: `{response}`")
    else:
        await ctx.send(f"üë¢ Player **{identifier}** kicked from ASA.")

@asa.command(name="ban", help="[Admin] Bans a player from the ASA server by Steam ID or name.")
@commands.has_permissions(administrator=True)
async def asa_ban(ctx, identifier: str):
    await ctx.defer()
    command = f"BanPlayer {identifier}"
    response = await run_asa_rcon_command(command)

    if "Command Failed" in response or "Unknown Command" in response:
        await ctx.send(f"‚ùå Could not ban player **{identifier}** from ASA. RCON Response: `{response}`")
    else:
        await ctx.send(f"üî® Player **{identifier}** banned from ASA.")

@asa.command(name="unban", help="[Admin] Unbans a player from the ASA server by Steam ID or name.")
@commands.has_permissions(administrator=True)
async def asa_unban(ctx, identifier: str):
    await ctx.defer()
    command = f"UnbanPlayer {identifier}"
    response = await run_asa_rcon_command(command)

    if "Command Failed" in response or "Unknown Command" in response:
        await ctx.send(f"‚ùå Could not unban player **{identifier}** from ASA. RCON Response: `{response}`")
    else:
        await ctx.send(f"‚úÖ Player **{identifier}** unbanned from ASA.")

@asa.command(name="save", help="[Admin] Forces the ASA server to save the world.")
@commands.has_permissions(administrator=True)
async def asa_save(ctx):
    await ctx.defer()
    command = "SaveWorld"
    response = await run_asa_rcon_command(command)

    if "Command Failed" in response or "Unknown Command" in response:
        await ctx.send(f"‚ùå Failed to force save the ASA world. RCON Response: `{response}`")
    else:
        await ctx.send(f"üíæ ASA World save initiated. Response: `{response.strip()}`")

@asa.command(name="shutdown", help="[Admin] Gracefully shuts down the ASA server. Usage: !asa shutdown <minutes> [message]")
@commands.has_permissions(administrator=True)
async def asa_shutdown(ctx, minutes: int, *, message: str = "Server is shutting down for maintenance. Please exit now."):
    """Gracefully shuts down the ASA server after a timed warning."""
    if minutes <= 0:
        return await ctx.send("‚ùå Please specify a shutdown time in minutes (e.g., `!asa shutdown 5`).")
    
    # Execute the asynchronous, non-blocking shutdown sequence
    asyncio.create_task(_execute_asa_graceful_shutdown(ctx, minutes, message))

@asa.command(name="doexit", help="[Admin] Forces the ASA server to immediately save and shut down/exit. USE WITH CAUTION.")
@commands.has_permissions(administrator=True)
async def asa_doexit(ctx):
    await ctx.defer()
    config = GAME_RCON_CONFIGS.get('asa')
    
    await ctx.send(f"üö® **{config['name']}** - Executing **IMMEDIATE** Save and Shutdown (`DoExit`)! This bypasses graceful warnings.")
    
    # Force save
    save_response = await run_asa_rcon_command("SaveWorld")
    if "Command Failed" in save_response:
        await ctx.send(f"‚ö†Ô∏è Warning: SaveWorld command failed before DoExit. Data loss possible. Response: `{save_response}`")
    else:
        await ctx.send("üíæ ASA World save initiated successfully.")
        
    # Execute shutdown (DoExit)
    response = await run_asa_rcon_command("DoExit")
    
    if "Command Failed" in response:
        await ctx.send(f"‚ùå DoExit command sent but RCON returned an error: `{response}`")
    else:
        await ctx.send(f"‚úÖ **{config['name']}** server sent shutdown command (`DoExit`). Server should now be offline.")

@asa.command(name="settime", help="[Admin] Sets the time of day (e.g., `!asa settime 14:30` or `!asa settime night`).")
@commands.has_permissions(administrator=True)
async def asa_settime(ctx, time_value: str):
    """Sets the time of day on the ASA server."""
    await ctx.defer()
    
    rcon_command = None
    display_time = ""
    time_value = time_value.lower()

    if time_value in ['day', 'noon']:
        rcon_command = "SetTimeOfDay 12:00"
        display_time = "Midday (12:00)"
    elif time_value in ['night', 'midnight']:
        rcon_command = "SetTimeOfDay 00:00"
        display_time = "Midnight (00:00)"
    elif re.match(r'^\d{1,2}:\d{2}$', time_value):
        # Specific HH:MM format validation
        try:
            h, m = map(int, time_value.split(':'))
            if 0 <= h < 24 and 0 <= m < 60:
                rcon_command = f"SetTimeOfDay {h:02d}:{m:02d}"
                display_time = f"{h:02d}:{m:02d}"
            else:
                return await ctx.send("‚ùå Invalid time. Hours must be 0-23 and minutes 0-59.")
        except ValueError:
             return await ctx.send("‚ùå Invalid time format. Use `HH:MM`, `day`, or `night`.")
    else:
        return await ctx.send("‚ùå Invalid time format. Use `HH:MM`, `day`, or `night`.")
    
    await ctx.send(f"‚è∞ Setting **ASA** time to **{display_time}**...")
    response = await run_asa_rcon_command(rcon_command)
    
    if "Command Failed" in response:
        await ctx.send(f"‚ùå Failed to set time. Error: `{response}`")
    else:
        await ctx.send(f"‚úÖ **ASA** time successfully set to **{display_time}**.")

@asa.command(name="creative", help="[Admin] Toggles creative mode for a player (or yourself). Usage: !asa creative [PlayerName/SteamID]")
@commands.has_permissions(administrator=True)
async def asa_creative(ctx, identifier: str = None):
    """Toggles creative mode for a specified player using GiveCreativeModeToPlayer."""
    await ctx.defer()
    
    target_id = identifier if identifier else ctx.author.display_name
    command = f"GiveCreativeModeToPlayer {target_id}" 
    
    await ctx.send(f"üî® Attempting to toggle creative mode for **{target_id}**...")
    response = await run_asa_rcon_command(command)

    if "Command Failed" in response:
        await ctx.send(f"‚ùå Failed to toggle creative mode for **{target_id}**. Error: `{response}`")
    else:
        await ctx.send(f"‚úÖ Creative mode toggle command sent for **{target_id}**. Response: `{response.strip()}`")

# ==============================================================================
# BACKGROUND TASKS
# ==============================================================================

@tasks.loop(minutes=AUTO_SAVE_INTERVAL_MINUTES)
async def pal_auto_save():
    """Palworld-specific auto-save task."""
    global target_channel, log_channel
    if 'target_channel' not in globals() or target_channel is None: 
        target_channel = bot.get_channel(TARGET_CHANNEL_ID)
    if 'log_channel' not in globals() or log_channel is None:
        log_channel = bot.get_channel(LOG_CHANNEL_ID)

    command = "Save"
    response = await run_rcon_command(PAL_RCON_HOST, PAL_RCON_PORT, PAL_RCON_PASSWORD, command)
    
    if target_channel and "Save Complete" in response:
        await target_channel.send(f"‚úÖ Palworld Server: World data auto-saved successfully! (Next save in {AUTO_SAVE_INTERVAL_MINUTES} mins)")
        print("Palworld auto-save complete.")
    elif log_channel and "Command Failed" in response:
        await log_channel.send(f"‚ö†Ô∏è Palworld Auto-Save Failed: {response}")
        print(f"Palworld auto-save failed: {response}")

@tasks.loop(minutes=AUTO_SAVE_INTERVAL_MINUTES)
async def asa_auto_save():
    """ASA-specific auto-save task."""
    global target_channel, log_channel
    if 'target_channel' not in globals() or target_channel is None: 
        target_channel = bot.get_channel(TARGET_CHANNEL_ID)
    if 'log_channel' not in globals() or log_channel is None:
        log_channel = bot.get_channel(LOG_CHANNEL_ID)

    command = "SaveWorld"
    response = await run_rcon_command(ASA_RCON_HOST, ASA_RCON_PORT, ASA_RCON_PASSWORD, command)
    
    if target_channel and "Command Failed" not in response:
        await target_channel.send(f"‚úÖ **{ASA_SERVER_NAME}** Server: World data auto-saved successfully! (Next save in {AUTO_SAVE_INTERVAL_MINUTES} mins)")
        print(f"{ASA_SERVER_NAME} auto-save complete.")
    elif log_channel and "Command Failed" in response:
        await log_channel.send(f"‚ö†Ô∏è **{ASA_SERVER_NAME}** Auto-Save Failed: {response}")
        print(f"{ASA_SERVER_NAME} auto-save failed: {response}")


async def check_player_activity(game_id: str, host: str, port: int, password: str, command: str, game_name: str):
    """Checks the player list for a server and reports joins/leaves."""
    global PAL_BAN_LIST_IDS
    response = await run_rcon_command(host, port, password, command)

    if "Command Failed" in response:
        return

    current_players = []
    
    global target_channel
    if 'target_channel' not in globals() or target_channel is None: 
        target_channel = bot.get_channel(TARGET_CHANNEL_ID)

    if game_id == 'mc':
        match = re.search(r"There are \d+ of \d+ players online:(.*)", response)
        if match:
            players_str = match.group(1).strip()
            current_players = [p.strip() for p in players_str.split(',') if p.strip()]
    
    elif game_id == 'pal':
        # Palworld format: Name,PlayerUID,SteamID
        lines = response.split('\n')
        
        for line in lines:
            parts = line.split(',')
            # Check for valid line structure and skip header/empty lines
            if len(parts) >= 3 and parts[0].strip() not in ('Name', 'name', ''):
                name = parts[0].strip()
                uid = parts[1].strip()
                steam_id = parts[2].strip()
                
                # --- PALWORLD AUTO-BAN CHECK LOGIC (Your requested feature) ---
                if PAL_BAN_LIST_IDS and (uid in PAL_BAN_LIST_IDS or steam_id in PAL_BAN_LIST_IDS):
                    # Player is banned, kick them immediately using their UID
                    kick_response = await run_pal_rcon_command(f"KickPlayer {uid}")
                    if target_channel:
                         await target_channel.send(f"üî® **{game_name}** | **Auto-Kick**: Banned player **{name}** (`{uid}`/`{steam_id}`) kicked on join. Response: `{kick_response.strip()}`")
                    print(f"Palworld: Auto-kicked banned player {name} ({uid}/{steam_id}).")
                    continue # Do not add to current_players list for join/leave tracking
                
                # If not banned, track them for join/leave messages
                current_players.append(name)
    
    elif game_id == 'asa':
        # ASA format: PlayerName,PlayerID,SteamID
        lines = response.split('\n')
        current_players = [line.split(',')[0].strip() for line in lines if line.count(',') >= 2 and line.split(',')[0].strip() not in ('PlayerName', 'name') and line.split(',')[0].strip()]


    last_players = last_player_list.get(game_id, [])
    
    if not last_players:
        last_player_list[game_id] = current_players
        return

    # Check for players who were present last time but are missing now
    left_players = [p for p in last_players if p not in current_players]
    # Check for players present now who were missing last time
    joined_players = [p for p in current_players if p not in last_players]
    
    if target_channel:
        for player in joined_players:
            await target_channel.send(f"‚ûï **{game_name}** | Player **{player}** joined the server!")
        
        for player in left_players:
            await target_channel.send(f"‚ûñ **{game_name}** | Player **{player}** left the server.")

    last_player_list[game_id] = current_players


@tasks.loop(seconds=SERVER_POLL_INTERVAL_SECONDS)
async def monitor_server_activity():
    """Task that runs continuously to check all server player lists."""
    await check_player_activity('mc', MC_RCON_HOST, MC_RCON_PORT, MC_RCON_PASSWORD, 'list', 'Minecraft')
    await check_player_activity('pal', PAL_RCON_HOST, PAL_RCON_PORT, PAL_RCON_PASSWORD, 'ShowPlayers', 'Palworld')
    await check_player_activity('asa', ASA_RCON_HOST, ASA_RCON_PORT, ASA_RCON_PASSWORD, 'ListPlayers', ASA_SERVER_NAME)


# ==============================================================================
# BOT EVENTS
# ==============================================================================

@bot.event
async def on_ready():
    """Event that runs when the bot connects and is ready."""
    print(f'Bot connected as {bot.user}')
    _load_pal_ban_list() # Load the ban list on startup
    print(f'Palworld ban list loaded with {len(PAL_BAN_LIST_IDS)} entries.')

    await bot.change_presence(status=Status.online, activity=Game("Monitoring Servers"))
    
    # Start all background tasks
    if not monitor_server_activity.is_running():
        monitor_server_activity.start()
    
    if not pal_auto_save.is_running():
        pal_auto_save.start()
        
    if not asa_auto_save.is_running():
        asa_auto_save.start()
    
    # Initialize channels globally upon startup
    global target_channel, log_channel
    target_channel = bot.get_channel(TARGET_CHANNEL_ID)
    log_channel = bot.get_channel(LOG_CHANNEL_ID)
    
    if not target_channel:
        print(f"WARNING: TARGET_CHANNEL_ID ({TARGET_CHANNEL_ID}) not found. Joins/Leaves/Auto-saves will not be posted.")


@bot.event
async def on_command_error(ctx, error):
    """Global command error handler."""
    if isinstance(error, commands.CommandNotFound):
        return
    
    if isinstance(error, commands.MissingPermissions):
        await ctx.send(f"‚ùå **Permission Denied!** You need **Administrator** permissions to use this command.")
        return

    print(f"Unhandled command error in {ctx.command}: {error}")
    await ctx.send(f"‚ùå An internal error occurred while running the command: `{error}`")
    
# ==============================================================================
# BOT RUN
# ==============================================================================

if DISCORD_TOKEN != "YOUR_DISCORD_BOT_TOKEN_HERE" and DISCORD_TOKEN:
    try:
        # Check if the token is valid before attempting to run
        if len(DISCORD_TOKEN) < 50: # Simple heuristic check for a valid token length
            print("WARNING: Discord token appears too short or invalid. Please check the DISCORD_TOKEN configuration.")
        
        bot.run(DISCORD_TOKEN)
    except Exception as e:
        print(f"Failed to run the bot. Check your DISCORD_TOKEN and permissions. Error: {e}")
else:
    print("FATAL: DISCORD_TOKEN is missing or set to the default placeholder. Please configure it.")
